package maintenance

import "time"

// Maintenance represents an Uptime Kuma maintenance window.
// Maintenance windows allow scheduling planned downtime to prevent false alerts
// during scheduled maintenance activities.
type Maintenance struct {
	// ID is the unique identifier for the maintenance window.
	ID int64 `json:"id"`

	// Title is the name of the maintenance window.
	Title string `json:"title"`

	// Description provides additional details about the maintenance.
	Description string `json:"description"`

	// Strategy defines the scheduling pattern for this maintenance window.
	// Valid values: "single", "recurring-interval", "recurring-weekday",
	// "recurring-day-of-month", "cron", "manual".
	Strategy string `json:"strategy"`

	// Active indicates whether the maintenance window is active.
	// When false, the maintenance will not trigger even if scheduled.
	Active bool `json:"active"`

	// IntervalDay specifies the interval in days for recurring-interval strategy.
	// Only used when Strategy is "recurring-interval".
	IntervalDay int `json:"intervalDay,omitempty"`

	// DateRange defines the start and end time for the maintenance window.
	// Array with exactly 2 elements: [startDate, endDate].
	// Elements can be nil for recurring strategies.
	DateRange []*time.Time `json:"dateRange"`

	// TimeRange defines the time of day range for recurring maintenance.
	// Array with exactly 2 elements: [startTime, endTime].
	// Only used for recurring strategies and cron.
	TimeRange []TimeOfDay `json:"timeRange,omitempty"`

	// Weekdays specifies which days of the week the maintenance occurs.
	// Values: 1-7 where Monday=1, Tuesday=2, ..., Sunday=7.
	// Only used when Strategy is "recurring-weekday".
	Weekdays []int `json:"weekdays,omitempty"`

	// DaysOfMonth specifies which days of the month the maintenance occurs.
	// Can be integers 1-31 or special strings "lastDay1"-"lastDay4".
	// Only used when Strategy is "recurring-day-of-month".
	DaysOfMonth []interface{} `json:"daysOfMonth,omitempty"`

	// Cron is a cron expression for cron-based scheduling.
	// Only used when Strategy is "cron".
	// Can also be auto-generated by server for recurring strategies.
	Cron string `json:"cron,omitempty"`

	// Duration is the duration of the maintenance window in seconds.
	// For recurring strategies, this is calculated by the server from TimeRange.
	// For cron strategy, this is calculated from DurationMinutes.
	Duration int `json:"duration,omitempty"`

	// DurationMinutes is the duration in minutes.
	// For recurring strategies, this is calculated by server as duration / 60.
	// For cron strategy, this should be provided by the client.
	DurationMinutes int `json:"durationMinutes,omitempty"`

	// Timezone is the resolved IANA timezone for the maintenance window.
	// Examples: "America/New_York", "Europe/London", "UTC".
	// When using "SAME_AS_SERVER", this will be set to the server's timezone.
	Timezone string `json:"timezone,omitempty"`

	// TimezoneOption is the original timezone option specified by the user.
	// Valid values: "UTC", "SAME_AS_SERVER", or a specific IANA timezone.
	TimezoneOption string `json:"timezoneOption,omitempty"`

	// TimezoneOffset is the timezone offset from UTC.
	// Example: "+02:00", "-05:00".
	// Computed by the server.
	TimezoneOffset string `json:"timezoneOffset,omitempty"`

	// Status is the current status of the maintenance window.
	// Valid values: "inactive", "scheduled", "under-maintenance", "ended", "unknown".
	// This is a read-only field computed by the server.
	Status string `json:"status,omitempty"`

	// TimeslotList contains the scheduled maintenance windows.
	// This is a read-only field computed by the server.
	TimeslotList []Timeslot `json:"timeslotList,omitempty"`
}

// TimeOfDay represents a specific time of day with hours, minutes, and seconds.
type TimeOfDay struct {
	Hours   int `json:"hours"`   // 0-23
	Minutes int `json:"minutes"` // 0-59
	Seconds int `json:"seconds"` // 0-59
}

// Timeslot represents a scheduled maintenance window with start and end times.
type Timeslot struct {
	StartDate time.Time `json:"startDate"`
	EndDate   time.Time `json:"endDate"`
}
